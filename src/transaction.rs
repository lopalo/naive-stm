use crate::{private, Error, Result, StmVar, StmVarId};
use rand::prelude::*;
use std::{
    any::Any,
    cell::RefCell,
    collections::{btree_map::Entry, BTreeMap},
    fmt,
    ops::{Deref, DerefMut},
    thread,
    time::Duration,
};

pub struct TxOptions {
    pub attempts: usize,
    pub retry_pause: Duration,
    pub pause_jitter: bool,
}

impl Default for TxOptions {
    fn default() -> Self {
        Self {
            attempts: 10,
            retry_pause: Duration::ZERO,
            pause_jitter: false,
        }
    }
}

enum TrackedVar {
    /// `TxVar` is moved into `TxRef`
    InUse,
    /// `TxRef` has been dropped, and it flushed `TxVar` back to a transaction
    Pending(Box<dyn TxVar>),
}

pub struct Tx {
    vars: RefCell<BTreeMap<StmVarId, TrackedVar>>,
}

enum CommitStatus {
    Success,
    Fail,
}

impl Tx {
    pub fn run<F, T, E>(f: F) -> Result<T, E>
    where
        F: FnMut(&Tx) -> Result<T, E>,
    {
        Self::run_with_options(&Default::default(), f)
    }

    pub fn run_with_options<F, T, E>(
        options: &TxOptions,
        mut f: F,
    ) -> Result<T, E>
    where
        F: FnMut(&Tx) -> Result<T, E>,
    {
        let TxOptions {
            attempts,
            retry_pause,
            pause_jitter,
        } = *options;
        let mut rng = rand::thread_rng();

        for attempt in 0..attempts {
            if attempt > 0 {
                let mut pause = retry_pause;
                if pause_jitter {
                    pause = pause.mul_f32(rng.gen())
                }
                thread::sleep(pause);
            }

            let tx = Self {
                vars: RefCell::new(BTreeMap::new()),
            };
            let res = f(&tx)?;
            match tx.commit() {
                CommitStatus::Success => return Ok(res),
                CommitStatus::Fail => (),
            }
        }

        Err(Error::TooManyTransactionRetryAttempts { attempts })
    }

    pub fn track<'tx, 'var, V: StmVar>(
        &'tx self,
        var: &'var V,
    ) -> Result<TxRef<'tx, V::TxVar>> {
        let var_id = var.var_id();
        let tx_var = match self.vars.borrow_mut().entry(var_id) {
            Entry::Vacant(entry) => {
                entry.insert(TrackedVar::InUse);
                Box::new(var.tx_var())
            }
            Entry::Occupied(mut entry) => {
                match std::mem::replace(entry.get_mut(), TrackedVar::InUse) {
                    TrackedVar::InUse => {
                        return Err(Error::TransactionVariableIsInUse(var_id))
                    }
                    TrackedVar::Pending(tx_var) => tx_var
                        .into_any()
                        .downcast()
                        .expect(
                        "BUG: variable type must be uniquely identified by its ID",
                    ),
                }
            }
        };
        Ok(TxRef {
            tx: self,
            var_id,
            var: Some(tx_var),
        })
    }

    fn commit(mut self) -> CommitStatus {
        // The variables will be locked in the ascending order of their IDs.
        let locked_vars: Vec<_> = self
            .vars
            .get_mut()
            .values_mut()
            .map(|tracked_var| {
                let TrackedVar::Pending(tx_var) = tracked_var else {
                    panic!("BUG: there must be no `TxRef` around for this transaction");
                };
                tx_var.lock()
            })
            .collect();
        for var in &locked_vars {
            if !var.can_commit() {
                return CommitStatus::Fail;
            }
        }
        for mut var in locked_vars {
            var.commit()
        }
        CommitStatus::Success
    }

    pub fn abort<T>() -> Result<T, ()> {
        Self::abort_with(())
    }

    pub fn abort_with<T, E>(error: E) -> Result<T, E> {
        Err(Error::TransactionAbort(error))
    }
}

/// Implementors must track the original version of variable's value
pub trait TxVar: private::Sealed + 'static {
    /// This method is called in the commit phase of a transaction.
    /// `LockedTxVar` is responsible for checking whether the variable's value
    /// has changed while the transaction was running.
    fn lock(&mut self) -> Box<dyn LockedTxVar + '_>;

    fn into_any(self: Box<Self>) -> Box<dyn Any>;
}

pub trait LockedTxVar: private::Sealed {
    /// Checks if the variable's value has changed since the first read
    fn can_commit(&self) -> bool;

    /// Writes data generated by a transaction to a shared transaction variable,
    /// thus making the changes visible to other transactions.
    fn commit(&mut self);
}

pub struct TxRef<'tx, T>
where
    // Unfortunately, `Drop` impl requires this bound on the struct
    T: TxVar,
{
    tx: &'tx Tx,
    var_id: StmVarId,
    var: Option<Box<T>>,
}

static NO_VAR_ERROR_MSG: &'static str =
    "BUG: transaction variable must be present for entire lifetime";

impl<T: TxVar> TxRef<'_, T> {
    fn get_var(&self) -> &T {
        self.var.as_deref().expect(NO_VAR_ERROR_MSG)
    }

    fn get_var_mut(&mut self) -> &mut T {
        self.var.as_deref_mut().expect(NO_VAR_ERROR_MSG)
    }
}

impl<'tx, T> Drop for TxRef<'tx, T>
where
    T: TxVar,
{
    fn drop(&mut self) {
        let Self { tx, var_id, var } = self;
        let tx_var_status = tx.vars.borrow_mut().insert(
            *var_id,
            TrackedVar::Pending(var.take().expect(NO_VAR_ERROR_MSG)),
        );
        let Some(TrackedVar::InUse) = tx_var_status else {
            panic!("BUG: transaction has not been tracking the variable `{var_id:?}`")
        };
    }
}

impl<T: TxVar> Deref for TxRef<'_, T> {
    type Target = T;

    fn deref(&self) -> &T {
        self.get_var()
    }
}

impl<T: TxVar> DerefMut for TxRef<'_, T> {
    fn deref_mut(&mut self) -> &mut T {
        self.get_var_mut()
    }
}

impl<T> fmt::Debug for TxRef<'_, T>
where
    T: TxVar + fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.var.fmt(f)
    }
}

#[macro_export]
macro_rules! track {
    ($tx:ident, $($stm_var:ident),+) => {
        $(let mut $stm_var = $tx.track(&$stm_var)?;)+
    };
}
