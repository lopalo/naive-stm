use crate::{Error, Result, StmVar, StmVarId};
use std::{
    cell::RefCell,
    collections::BTreeMap,
    fmt,
    ops::{Deref, DerefMut},
    time::Duration,
};

pub struct TxOptions {
    pub retries: usize,
    pub retry_pause: Duration,
    pub pause_jitter: bool,
}

impl Default for TxOptions {
    fn default() -> Self {
        Self {
            retries: 10,
            retry_pause: Duration::ZERO,
            pause_jitter: false,
        }
    }
}

enum TrackedVar {
    /// `TxVar` is moved into `TxRef`
    InUse,
    /// `TxRef` has been dropped, and it flushed `TxVar` back to a transaction
    Pending(Box<dyn TxVar>),
}

pub struct Tx {
    vars: RefCell<BTreeMap<StmVarId, TrackedVar>>,
}

enum CommitStatus {
    Success,
    Fail,
}

impl Tx {
    pub fn run<T, F>(f: F) -> Result<T>
    where
        F: Fn(&Tx) -> Result<T>,
    {
        Self::run_with_options(&Default::default(), f)
    }

    pub fn run_with_options<T, F>(options: &TxOptions, f: F) -> Result<T>
    where
        F: Fn(&Tx) -> Result<T>,
    {
        //TODO: use all `TxOptions` fields
        for _ in 0..options.retries {
            let tx = Self {
                vars: RefCell::new(BTreeMap::new()),
            };
            let res = f(&tx)?;
            match tx.commit() {
                CommitStatus::Success => return Ok(res),
                CommitStatus::Fail => (),
            }
        }
        Err(Error::TooManyTransactionRetryAttempts)
    }

    // TODO: must return error if var is in `self.vars` and in `InUse` state.
    // TODO: Use Box<Any>::downcast
    pub fn track<'tx, 'var: 'tx, V: StmVar>(
        &'tx self,
        var: &'var V,
    ) -> Result<TxRef<'tx, V::TxVar>> {
        todo!()
    }

    fn commit(self) -> CommitStatus {
        todo!()
    }
}

/// Implementors must track the original version of variable's value
pub(crate) trait TxVar {
    /// This method is called in the commit phase of a transaction.
    /// `LockedTxVar` is responsible for checking whether the variable's value
    /// has changed while the transaction was running.
    fn lock(&mut self) -> Box<dyn LockedTxVar + '_>;
}

pub(crate) trait LockedTxVar {
    /// Checks if the variable's value has changed since the first read
    fn can_commit(&self) -> bool;

    /// Writes data generated by a transaction to a shared transaction variable,
    /// thus making the changes visible to other transactions.
    fn commit(&mut self);
}

//TODO: implement Drop that flushes TxVar back to the `tx` as a trait object
pub struct TxRef<'tx, T: 'tx> {
    tx: &'tx Tx,
    var: Box<T>,
}

impl<T> Deref for TxRef<'_, T> {
    type Target = T;

    fn deref(&self) -> &T {
        self.var.deref()
    }
}

impl<T> DerefMut for TxRef<'_, T> {
    fn deref_mut(&mut self) -> &mut T {
        self.var.deref_mut()
    }
}

impl<T: fmt::Debug> fmt::Debug for TxRef<'_, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.var.fmt(f)
    }
}

//TODO: macro track!(tx, var1, var2) => {let var1 = tx.track(var1)?; let var2 = tx.track(var2)?}
